Anotações do curso:

Anotação 1: 
<img [src]="url" [alt]="title">
com o [] o angular irá saber que terá que buscar o valor do component.ts
One way data binding 

<h1> {{ title }}</h1> 
usado no caso do data binding de um atributo html, usar quando for exebido um valor em uma tag, 
isoladamente. 
Ou seja, Utilizamos {{ }} dentro de tags e [ ] para atributos


Anotação 2:
Instalar bootstrap através do npm (npm install bootstrap 4.1.1)
no angular.json, na chave build, dentro do styles, adicionar o caminho do boostrap dentro da node_modules/dist


Anotação 3:
Todo component, vai precisar informar o nome do selector, sempre colocar uma abreviação na frente
exemplo: ap-phoho (aluraPic), caso por padrão o Angular criar o component photo, isso seria um problema,
porém como está utilizando a abreviação, não teremos problema.

Anotação 4:
Para trabalhar com consumos de API, o angular tem modulo nativo, que é o HttpClient.
Para utilizar é necessário importar no app.module.ts 
HttpClientModule no imports e import { HttpClientModule } from '@angular/common/http';
e para injeção de dependência no construtor na classe:
  constructor(http: HttpClient){
    console.log(http);
  }


Anotação 5:
photo.service.ts serviço genérico para consumir as fotos da API.
o @Injectable({providedIn: 'root'}) com escopo raiz, qualquer component da aplicação que precisar, terá disponivel.
Por isso o providedIn: 'root'.
Já anotação @Injectable, sem ela dará erro, pois como é uma injeção de dependência (chamada o http) é necessário
colocar a anotação.

Anotação 6:
Criado interface photo.ts onde foi definido todos os nome do retorno da API e qual o tipo dos dados,
assim, terá o autocomplete e menos erros.


Anotação 7:
Explição para o private na classe photo.component.ts
 constructor(private http: HttpClient){} 
    listFromUser(userName: string){
        return this.http.get<Photo[]>(`${API}/${userName}/photos`);
    }
    
private e o this, para ser possível ouvir o http dentro da função, 
sem isso, o http só seria ouvido direto do construtor apenas
Isso é um exemplo, está espalhado pelo código e poderá ser usado a qualquer momento em qualquer classe.

Anotação 8:
Boa pratica necessária:
Todo module, importar CommonModule.

Anotação 9:
Na rotas, quando for passado uma URL inexistente tratar da seguinte maneira no app.routing.module.ts
no caso do projeto, na const routes que é um array de Routes, adicionar:
{ path: '**', component: NotFoundComponent }
Ou seja, o caminho (path) não encontrado ('**'), irá chamar o component criado NotFoundComponent

Anotação 10:
Foi criado o componente photos dentro de photo-list, para isolar o comportamente da regra de 
carregando das fotos, como tem uma alta acoplação com photos list, foi criado dentro do mesmo lugar.

Anotação 11:
no componente photo-list.component.html 
o (keyup)="filter = $event.target.value" é a mesma que coisa que no javascript puro:
elemento.addEventListener('keyup', (event) => event.target.value)
Observação importante:
(keyup) o () é para indiciar que é um EventBind, ou seja, para o evento keyup, irá avaliar a expressão,
diferente do [] que indica DataBind, que recebe um dado definito pelo componente. Resumindo
[] = O evento é disparado dado vem do componente para o template, nunca o contrário 
() = O evento é disparado vai do template para o componente, nunca o contrário
Ambos são unidiricionais. 

Anotação 12:
exemplo:
no component.ts terá nome = 'guilherme'
no component.html quero fazer um pipe (tubo) para colocar em maiusculo, ficará:
{{ nome | uppercase}}
no photo-list.component.html tem um filtro
<ap-photos [photos]="photos | filterByDescription: filter"></ap-photos>
ou seja, irá pegar as photos | (transformar) filtrando pela descrição e aplicando o filtro
Sendo que, o filterByDescription foi criado filterByDescription.pipe.ts. O Angular tem a propriedade
exclusiva para criação do pipe, lembrando que é necessário utilizar o decorador @pipe.
Lembrar também, que tem a interface PipeTransform para utilizar. 
No module o pipe também precisa ser declarado


Anotação 13:
Existe também a criação do resolver (photo-list.resolver.ts).
 O Angular, por meio do Resolver, capaz de lidar com dados durante a navegação de uma rota para d
 isponibilizá-los a um componente antes deste ser carregado


 Anotação 14:
 No photo-list.component.ts, foi utilizado um debounce, usando componente do rxjs para os milisegundos.
 Foi implementado a interface OnDestroy, isso é muito importante, para não ficar ocupando memoria 
 desnecessaria.

 Anotação 15:
 No load-button.component.html tem a utilização de if else no template
 <div class="text-center" *ngIf="hasMore; else messageTemplate">
 isso está sendo feito, para caso ouver dados, mostrar o botão se não o messageTemplate 
 que é:
 <ng-template #messageTemplate>
  <p class="text-center text-muted">No more data to load</p>
</ng-template>
#messageTemplate indica o nome da variavel dada ao ng-template
